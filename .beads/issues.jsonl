{"id":"llmring-1ga","title":"Clarify/implement runtime fallback across alias model pools","description":"Docs claim automatic failover across the full model pool for an alias (rate limits/outages), but AliasResolver.resolve only selects the first model whose provider has an API key; LLMRing.chat does not retry through Lockfile.resolve_alias(...) on provider errors. Either implement retry+fallback behavior or narrow docs to “provider-availability selection”.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-02T18:25:07.558838Z","created_by":"juanre","updated_at":"2026-01-02T21:51:03.672022Z","closed_at":"2026-01-02T21:51:03.672022Z","close_reason":"Implemented real runtime failover across alias model pools: LLMRing.chat retries next candidate on provider/model errors; chat_stream retries before first chunk. Added non-mocking unit tests."}
{"id":"llmring-1iy","title":"Fix pyright warnings in MCP info_service","description":"pyright passes (0 errors) but reports two reportUnusedExpression warnings in src/llmring/mcp/client/info_service.py (around lines 541 and 600). Remove/replace the stray expression statements to get to 0 warnings without behavior change.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-02T20:53:18.932963Z","created_by":"juanre","updated_at":"2026-01-02T21:23:17.044682Z","closed_at":"2026-01-02T21:23:17.044682Z","close_reason":"Removed two stray unused datetime expressions; pyright now reports 0 warnings.","dependencies":[{"issue_id":"llmring-1iy","depends_on_id":"llmring-yww","type":"discovered-from","created_at":"2026-01-02T20:53:18.933794Z","created_by":"juanre"}]}
{"id":"llmring-1lq","title":"Sync docs with code: StreamChunk fields, provider interface, and LLMRingSession naming","description":"Docs/README/ADRs use StreamChunk.content and describe protocol-based providers + LLMRingExtended as primary; code uses StreamChunk.delta, providers subclass BaseLLMProvider (ABC), and LLMRingExtended is a compatibility alias for LLMRingSession (src/llmring/service_extended.py). Update docs/examples and/or provide backwards-compatible aliases.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-02T18:25:02.826558Z","created_by":"juanre","updated_at":"2026-01-02T21:21:18.481982Z","closed_at":"2026-01-02T21:21:18.481982Z","close_reason":"Synced docs/examples with current APIs (StreamChunk.delta, BaseLLMProvider ABC interface, LLMRingSession, MCP streaming)."}
{"id":"llmring-35h","title":"Fix version mismatch: pyproject vs llmring.__version__","description":"pyproject.toml sets version to 1.3.0, but src/llmring/__init__.py sets __version__ = \"1.2.0\"; unify to a single source of truth so runtime and packaging metadata agree.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-02T18:25:00.24681Z","created_by":"juanre","updated_at":"2026-01-02T20:54:04.311601Z","closed_at":"2026-01-02T20:54:04.311601Z","close_reason":"Runtime version now sourced from package metadata via importlib.metadata.version (no hardcoded mismatch)"}
{"id":"llmring-3tw","title":"Consolidate KNOWN_PROVIDERS to single source of truth","description":"## Problem\n\n`KNOWN_PROVIDERS` is hardcoded in two separate places:\n\n1. `src/llmring/services/alias_resolver.py:15`:\n```python\nKNOWN_PROVIDERS = {\"openai\", \"anthropic\", \"google\", \"ollama\"}\n```\n\n2. `src/llmring/lockfile_core.py:537`:\n```python\nreturn prefix in {\"openai\", \"anthropic\", \"google\", \"ollama\"}\n```\n\nIf a new provider is added, both locations must be updated. This violates DRY and is error-prone.\n\n## Fix\n\nDefine `KNOWN_PROVIDERS` once in a constants module and import it everywhere:\n\n```python\n# src/llmring/constants.py\nKNOWN_PROVIDERS = frozenset({\"openai\", \"anthropic\", \"google\", \"ollama\"})\n```\n\nThen import in both files:\n```python\nfrom llmring.constants import KNOWN_PROVIDERS\n```\n\n## Acceptance criteria\n- [ ] Add KNOWN_PROVIDERS to src/llmring/constants.py\n- [ ] Update alias_resolver.py to import from constants\n- [ ] Update lockfile_core.py to import from constants\n- [ ] All tests pass","status":"closed","priority":2,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:24:04.399823+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:42:44.045082+01:00","closed_at":"2026-01-23T19:42:44.045082+01:00","close_reason":"Moved KNOWN_PROVIDERS to constants.py, updated imports in both files. All tests pass."}
{"id":"llmring-4ip","title":"Log TypeError/AttributeError instead of silently ignoring","description":"## Problem\n\nIn `discover_package_lockfile()` at `src/llmring/lockfile_core.py:64-67`:\n\n```python\nexcept (ModuleNotFoundError, TypeError, AttributeError):\n    # ModuleNotFoundError: package not installed\n    # TypeError/AttributeError: defensive catch for malformed package names\n    pass  # Silent failure - could hide bugs\n```\n\n`TypeError` and `AttributeError` often indicate code bugs, not expected conditions. Silently swallowing them makes debugging harder.\n\n## Fix\n\nLog TypeError/AttributeError at warning level before returning None:\n\n```python\nimport logging\nlogger = logging.getLogger(__name__)\n\ndef discover_package_lockfile(package_name: str) -\u003e Optional[Path]:\n    try:\n        ...\n    except ModuleNotFoundError:\n        # Expected: package not installed\n        return None\n    except (TypeError, AttributeError) as e:\n        # Unexpected: log for debugging, but still return None gracefully\n        logger.warning(f\"Unexpected error discovering lockfile for {package_name!r}: {e}\")\n        return None\n```\n\n## Acceptance criteria\n- [ ] Separate ModuleNotFoundError from TypeError/AttributeError\n- [ ] Log TypeError/AttributeError at warning level\n- [ ] Include package name and exception in log message\n- [ ] Tests still pass","status":"closed","priority":3,"issue_type":"bug","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:24:13.686917+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:44:54.683371+01:00","closed_at":"2026-01-23T19:44:54.683371+01:00","close_reason":"Already implemented as part of the security fix in llmring-5im. TypeError/ValueError are now logged at warning level."}
{"id":"llmring-4jj","title":"Fix cache key inconsistency for profile resolution","description":"## Problem\n\nIn `AliasResolver` at `src/llmring/services/alias_resolver.py`, cache keys are created inconsistently:\n\n**Unqualified aliases (line 144-148):**\n```python\ncache_key = (alias_or_model, profile)  # profile could be None\nif cache_key in self._cache:\n    cached_value = self._cache[cache_key]\n```\n\n**Namespaced aliases (line 188-191):**\n```python\nprofile_name = profile or os.getenv(\"LLMRING_PROFILE\")  # Resolved from env\ncache_key = (full_alias, profile_name)  # Uses resolved profile\nif cache_key in self._cache:\n```\n\nThis means the same lookup with `profile=None` might be cached under different keys:\n- Unqualified: `(\"fast\", None)` \n- Namespaced: `(\"libA:fast\", \"default\")` if LLMRING_PROFILE=default\n\n## Fix\n\nNormalize the profile name BEFORE creating cache keys:\n\n```python\ndef resolve(self, alias_or_model: str, profile: Optional[str] = None) -\u003e str:\n    # Normalize profile name early\n    resolved_profile = profile or os.getenv(\"LLMRING_PROFILE\")\n    cache_key = (alias_or_model, resolved_profile)\n    ...\n```\n\nApply same pattern in `_resolve_namespaced_alias`.\n\n## Acceptance criteria\n- [ ] Profile is resolved to actual value before cache key creation\n- [ ] Both unqualified and namespaced aliases use same resolution logic\n- [ ] No duplicate cache entries for same conceptual lookup\n- [ ] Tests pass","status":"closed","priority":2,"issue_type":"bug","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:24:36.51028+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:43:56.827599+01:00","closed_at":"2026-01-23T19:43:56.827599+01:00","close_reason":"Profile is now resolved at start of resolve() before cache key creation. All tests pass."}
{"id":"llmring-4kn","title":"Lockfile composability with namespaced aliases","description":"Enable libraries to ship lockfiles that consumers can extend and override using namespaced aliases.\n\n## Design\n\n**Consumer's lockfile:**\n```toml\n[extends]\npackages = [\"libA\", \"libB\"]\n\n# Optional: override libA's alias\n[[profiles.default.bindings]]\nalias = \"libA:summarizer\"\nmodels = [\"openai:gpt-4o-mini\"]\n```\n\n**Consumer's code:**\n```python\n# Explicit: using libA's alias (possibly overridden)\nring.chat(\"libA:summarizer\", messages=[...])\n\n# Unqualified: local only\nring.chat(\"summarizer\", messages=[...])\n```\n\n## Resolution Rules\n1. `libA:summarizer` → check consumer lockfile for `libA:summarizer`, else check libA's lockfile for `summarizer`\n2. `summarizer` (unqualified) → consumer lockfile only\n\n## Discovery\nUse importlib.resources to find package location, convention `\u003cpackage\u003e/llmring.lock` for filename.","status":"closed","priority":2,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T11:49:58.03971+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T15:42:42.988665+01:00","closed_at":"2026-01-23T15:42:42.988665+01:00","close_reason":"All subtasks completed: extends parsing, package discovery, namespaced alias resolution, require_aliases support, CLI check command, documentation, and tests","labels":["epic"]}
{"id":"llmring-4kn.1","title":"Parse [extends] section in lockfile","description":"Add parsing for new [extends] section in lockfile TOML:\n\n```toml\n[extends]\npackages = [\"libA\", \"libB\"]  # Package names\n# Future: paths = [\"./vendor/lib/llmring.lock\"]  # Explicit paths\n```\n\n## Files to modify\n- `src/llmring/lockfile_core.py`: Add `extends` field to Lockfile model (Pydantic)\n- `src/llmring/lockfile_core.py`: Update `Lockfile.load()` to parse [extends] section\n\n## Acceptance criteria\n- [ ] Lockfile model has `extends: Optional[ExtendsConfig]` field\n- [ ] ExtendsConfig model has `packages: List[str]` field\n- [ ] load() parses [extends] without error\n- [ ] Missing [extends] section defaults to empty list\n- [ ] Invalid package names raise ValidationError\n\n## Example\n```python\nlockfile = Lockfile.load(\"llmring.lock\")\nprint(lockfile.extends.packages)  # [\"libA\", \"libB\"]\n```","status":"closed","priority":2,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T11:50:06.71663+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T12:04:41.69801+01:00","closed_at":"2026-01-23T12:04:41.69801+01:00","close_reason":"Implemented ExtendsConfig model, added extends field to Lockfile, updated load() to parse [extends] section with PEP 508 package name validation. All 9 acceptance tests passing.","dependencies":[{"issue_id":"llmring-4kn.1","depends_on_id":"llmring-4kn","type":"parent-child","created_at":"2026-01-23T11:50:06.718125+01:00","created_by":"Juan Reyero"}]}
{"id":"llmring-4kn.2","title":"Implement package lockfile discovery via importlib","description":"Implement function to discover lockfile from installed package.\n\n## Files to modify\n- `src/llmring/lockfile_core.py`: Add `discover_package_lockfile()` function\n\n## Implementation\n```python\ndef discover_package_lockfile(package_name: str) -\u003e Path | None:\n    \"\"\"Find llmring.lock in an installed package.\n    \n    Uses importlib.resources to locate the package, then looks for\n    llmring.lock in the package root directory.\n    \n    Returns None if package not found or has no lockfile.\n    \"\"\"\n    from importlib.resources import files, as_file\n    try:\n        package_files = files(package_name)\n        lockfile_traversable = package_files / \"llmring.lock\"\n        # Need to materialize to check if it exists\n        with as_file(lockfile_traversable) as lockfile_path:\n            if lockfile_path.exists():\n                return lockfile_path\n    except (ModuleNotFoundError, TypeError, FileNotFoundError):\n        pass\n    return None\n```\n\n## Acceptance criteria\n- [ ] Returns Path when package has llmring.lock\n- [ ] Returns None when package not installed\n- [ ] Returns None when package has no llmring.lock\n- [ ] Works with packages installed via pip/uv\n- [ ] Works with editable installs (pip install -e)\n- [ ] Handles namespace packages correctly\n\n## Edge cases\n- Package installed but no llmring.lock → None\n- Package not installed → None  \n- Package name typo → None (no error thrown)","status":"closed","priority":2,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T11:50:14.314092+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T12:38:58.229983+01:00","closed_at":"2026-01-23T12:38:58.229983+01:00","close_reason":"Implemented discover_package_lockfile() using importlib.resources. All 4 acceptance tests passing. Handles package not installed, no lockfile, and invalid names gracefully.","dependencies":[{"issue_id":"llmring-4kn.2","depends_on_id":"llmring-4kn","type":"parent-child","created_at":"2026-01-23T11:50:14.315237+01:00","created_by":"Juan Reyero"}]}
{"id":"llmring-4kn.3","title":"Implement namespaced alias resolution","description":"Update AliasResolver to handle namespaced aliases like `libA:summarizer`.\n\n## Prerequisites\n- llmring-4kn.1 (parse [extends])\n- llmring-4kn.2 (discover_package_lockfile)\n\n## Files to modify\n- `src/llmring/alias_resolver.py`: Update `resolve_alias()` method\n- `src/llmring/alias_resolver.py`: Add `_parse_namespaced_alias()` helper\n- `src/llmring/alias_resolver.py`: Add `_extended_lockfiles` cache\n\n## Resolution logic\n1. Parse alias: `_parse_namespaced_alias(\"libA:summarizer\")\" → (\"libA\", \"summarizer\")\n2. If namespaced:\n   a. Check consumer lockfile for exact match `libA:summarizer` (override)\n   b. If not found, load libA's lockfile via discover_package_lockfile()\n   c. Resolve `summarizer` in libA's lockfile\n3. If unqualified:\n   a. Consumer lockfile only (never check extended)\n\n## Acceptance criteria\n- [ ] `libA:summarizer` resolves from libA's lockfile\n- [ ] Consumer can override with `alias = \"libA:summarizer\"` in their lockfile\n- [ ] Unqualified `summarizer` only checks consumer lockfile\n- [ ] Extended lockfiles are cached (not reloaded on every resolve)\n- [ ] Clear error if package not in [extends]\n- [ ] Clear error if alias not found in package lockfile\n\n## Error messages\n```\nAliasNotFoundError: Alias 'libA:summarizer' not found.\n  Package 'libA' is in [extends] but its lockfile has no 'summarizer' alias.\n  Available aliases in libA: analyzer, embedder\n```\n\n```\nAliasNotFoundError: Cannot resolve 'libA:summarizer'.\n  Package 'libA' is not listed in [extends].packages.\n  Add it to your lockfile: [extends] packages = [\"libA\"]\n```","status":"closed","priority":2,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T11:50:22.656026+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T12:47:15.996153+01:00","closed_at":"2026-01-23T12:47:15.996153+01:00","close_reason":"Implemented namespaced alias resolution with caching, consumer override support, and clear error messages. All 23 tests passing including 8 new namespaced alias tests.","dependencies":[{"issue_id":"llmring-4kn.3","depends_on_id":"llmring-4kn","type":"parent-child","created_at":"2026-01-23T11:50:22.656871+01:00","created_by":"Juan Reyero"}]}
{"id":"llmring-4kn.4","title":"Update require_aliases for namespaced aliases","description":"Update `require_aliases()` to support namespaced aliases.\n\n## Prerequisites\n- llmring-4kn.3 (namespaced resolution)\n\n## Files to modify\n- `src/llmring/lockfile_core.py`: Update `require_aliases()` method\n\n## Implementation\n```python\ndef require_aliases(\n    self, \n    required: List[str],\n    profile: Optional[str] = None,\n    context: Optional[str] = None\n) -\u003e None:\n    \"\"\"Validate required aliases exist. Supports namespaced aliases.\"\"\"\n    missing = []\n    for alias in required:\n        try:\n            self.resolve_alias(alias, profile=profile)\n        except AliasNotFoundError:\n            missing.append(alias)\n    \n    if missing:\n        # Build helpful error message\n        raise ValueError(...)\n```\n\n## Acceptance criteria\n- [ ] Works with unqualified aliases: `require_aliases([\"summarizer\"])`\n- [ ] Works with namespaced aliases: `require_aliases([\"libA:summarizer\"])`\n- [ ] Works with mixed: `require_aliases([\"local\", \"libA:remote\"])`\n- [ ] Error message lists all missing aliases\n- [ ] Error message shows which lockfile was checked for each\n\n## Error message example\n```\nValueError: Missing required aliases for my-library (profile: default):\n  - summarizer: not found in consumer lockfile\n  - libA:analyzer: not found in libA lockfile (libA has: embedder, chat)\nLockfile path: /path/to/llmring.lock\n```","status":"closed","priority":2,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T11:50:29.901865+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T15:32:35.325576+01:00","closed_at":"2026-01-23T15:32:35.325576+01:00","close_reason":"Updated require_aliases for namespaced alias support with detailed error messages. All 65 tests passing.","dependencies":[{"issue_id":"llmring-4kn.4","depends_on_id":"llmring-4kn","type":"parent-child","created_at":"2026-01-23T11:50:29.90259+01:00","created_by":"Juan Reyero"}]}
{"id":"llmring-4kn.5","title":"CLI: llmring lock check for extends validation","description":"Add CLI validation command for extended lockfiles.\n\n## Prerequisites\n- llmring-4kn.1, .2, .3 (core functionality)\n\n## Files to modify\n- `src/llmring/cli/lock.py`: Add `check` subcommand\n\n## Command\n```bash\nllmring lock check [--lockfile PATH]\n```\n\n## Checks performed\n1. Parse [extends] section\n2. For each package in extends:\n   - Check package is installed\n   - Check package has llmring.lock\n   - Load and validate lockfile\n   - List aliases found\n3. Warn on alias conflicts (same alias in multiple packages)\n4. Summary of all available aliases\n\n## Output format\n```\nChecking lockfile: ./llmring.lock\n\n[extends]\n  ✓ libA: found llmring.lock\n    Aliases: summarizer, analyzer, embedder\n  ✓ libB: found llmring.lock\n    Aliases: translator, chat\n  ✗ libC: package not installed\n\nWarnings:\n  ⚠ 'summarizer' defined in both libA and libB\n    Use libA:summarizer or libB:summarizer to disambiguate\n\nLocal aliases:\n  myalias → anthropic:claude-sonnet-4-20250514\n\nSummary: 2/3 packages OK, 6 extended aliases, 1 local alias\n```\n\n## Exit codes\n- 0: All OK\n- 1: Missing packages or lockfiles\n- 2: Lockfile parse error\n\n## Acceptance criteria\n- [ ] Lists all extended packages and their aliases\n- [ ] Warns on conflicts\n- [ ] Fails if package not installed\n- [ ] Fails if package has no lockfile\n- [ ] Works with --lockfile flag for non-default paths","status":"closed","priority":2,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T11:50:37.560592+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T15:39:48.099755+01:00","closed_at":"2026-01-23T15:39:48.099755+01:00","close_reason":"Implemented and tested CLI lock check command","dependencies":[{"issue_id":"llmring-4kn.5","depends_on_id":"llmring-4kn","type":"parent-child","created_at":"2026-01-23T11:50:37.561866+01:00","created_by":"Juan Reyero"}]}
{"id":"llmring-4kn.6","title":"Documentation: Library authors guide for lockfile composability","description":"Document lockfile composability for library authors and consumers.\n\n## Prerequisites\n- All implementation beads complete\n\n## Files to modify\n- `docs/lockfile.md`: Add 'Composability' section\n- `skills/lockfile/SKILL.md`: Update library patterns section\n- `README.md`: Add example to quick start\n\n## Documentation outline\n\n### For library authors (docs/lockfile.md)\n1. **Shipping a lockfile**\n   - Place llmring.lock in package root\n   - Include in package_data/MANIFEST.in\n   \n2. **Declaring required aliases**\n   ```python\n   ring.require_aliases([\"summarizer\"], context=\"my-library\")\n   ```\n\n3. **Allowing overrides**\n   - Accept lockfile_path parameter\n   - Document which aliases your library needs\n\n4. **Alias naming best practices**\n   - Avoid generic names (summarizer → mylib_summarizer)\n   - Or rely on namespacing (consumers use mylib:summarizer)\n\n### For consumers (docs/lockfile.md)\n1. **Extending library lockfiles**\n   ```toml\n   [extends]\n   packages = [\"libA\", \"libB\"]\n   ```\n\n2. **Using namespaced aliases**\n   ```python\n   ring.chat(\"libA:summarizer\", ...)\n   ```\n\n3. **Overriding library aliases**\n   ```toml\n   [[profiles.default.bindings]]\n   alias = \"libA:summarizer\"\n   models = [\"openai:gpt-4o-mini\"]\n   ```\n\n4. **Validating setup**\n   ```bash\n   llmring lock check\n   ```\n\n## Acceptance criteria\n- [ ] Library author guide with complete example\n- [ ] Consumer guide with complete example\n- [ ] SKILL.md updated with new patterns\n- [ ] README has minimal example\n- [ ] All code examples tested","status":"closed","priority":2,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T11:50:45.62768+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T15:42:33.344628+01:00","closed_at":"2026-01-23T15:42:33.344628+01:00","close_reason":"Added composability docs to SKILL.md and README.md","dependencies":[{"issue_id":"llmring-4kn.6","depends_on_id":"llmring-4kn","type":"parent-child","created_at":"2026-01-23T11:50:45.628402+01:00","created_by":"Juan Reyero"}]}
{"id":"llmring-4kn.7","title":"Tests for lockfile composability","description":"Comprehensive tests for lockfile composability.\n\n## Prerequisites\n- Run in parallel with implementation (TDD)\n\n## Files to create/modify\n- `tests/test_lockfile_extends.py`: New test file\n- `tests/fixtures/fake_packages/`: Test package fixtures\n\n## Test fixtures needed\nCreate fake packages for testing:\n```\ntests/fixtures/fake_packages/\n├── libA/\n│   ├── __init__.py\n│   └── llmring.lock  # has: summarizer, analyzer\n├── libB/\n│   ├── __init__.py\n│   └── llmring.lock  # has: translator, summarizer (conflict)\n└── libC/\n    └── __init__.py   # no lockfile\n```\n\n## Unit tests\n\n### test_parse_extends_section\n- Empty [extends] → empty list\n- Single package → [\"libA\"]\n- Multiple packages → [\"libA\", \"libB\"]\n- Missing section → None/empty\n\n### test_discover_package_lockfile\n- Package with lockfile → returns Path\n- Package without lockfile → returns None\n- Package not installed → returns None\n- Editable install → returns Path\n\n### test_namespaced_alias_resolution\n- `libA:summarizer` → resolves from libA\n- `libA:summarizer` with consumer override → uses override\n- `summarizer` (unqualified) → consumer only\n- `libA:nonexistent` → AliasNotFoundError\n- `notinextends:alias` → error about missing extends\n\n### test_require_aliases_namespaced\n- All found → passes\n- Missing namespaced → fails with details\n- Mixed local and namespaced → works\n\n## Integration tests\n\n### test_full_resolution_chain\n- Consumer extends libA, libB\n- Override libA:summarizer\n- Resolve various aliases\n- Verify correct models returned\n\n### test_cli_lock_check\n- Happy path → exit 0\n- Missing package → exit 1\n- Conflict warning → exit 0 with warning\n\n## Edge case tests\n- Circular extends (A extends B extends A) → error\n- Package in extends but not installed → clear error\n- Same alias in multiple packages → resolution order / warning\n\n## Acceptance criteria\n- [ ] \u003e90% coverage on new code\n- [ ] All edge cases covered\n- [ ] Tests run in \u003c10s\n- [ ] No flaky tests","status":"closed","priority":2,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T11:50:53.188781+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T15:40:58.731032+01:00","closed_at":"2026-01-23T15:40:58.731032+01:00","close_reason":"Tests written via TDD during implementation (94 tests covering all scenarios). Circular extends test not needed - no recursive resolution in current design.","dependencies":[{"issue_id":"llmring-4kn.7","depends_on_id":"llmring-4kn","type":"parent-child","created_at":"2026-01-23T11:50:53.189508+01:00","created_by":"Juan Reyero"}]}
{"id":"llmring-5bo","title":"Fix has_alias to not swallow unexpected exceptions","description":"## Problem\n\nIn `Lockfile.has_alias()` at `src/llmring/lockfile_core.py:472-476`:\n\n```python\ndef has_alias(self, alias: str, profile: Optional[str] = None) -\u003e bool:\n    try:\n        models = self.resolve_alias(alias, profile)\n        return len(models) \u003e 0\n    except (KeyError, ValueError, IndexError, AttributeError):\n        return False\n```\n\nThis catches `AttributeError` and returns `False`, but `AttributeError` typically indicates a code bug (accessing attribute on None, typo in attribute name, etc.), not \"alias doesn't exist\".\n\n## Fix\n\nOnly catch expected exceptions:\n\n```python\ndef has_alias(self, alias: str, profile: Optional[str] = None) -\u003e bool:\n    \"\"\"Check if alias exists. Returns False only for missing aliases.\"\"\"\n    try:\n        models = self.resolve_alias(alias, profile)\n        return len(models) \u003e 0\n    except (KeyError, ValueError):\n        # Expected: alias not found, invalid format\n        return False\n    # Let AttributeError, IndexError propagate - they indicate bugs\n```\n\n## Acceptance criteria\n- [ ] Remove AttributeError and IndexError from except clause\n- [ ] Only catch KeyError and ValueError\n- [ ] Update docstring to clarify behavior\n- [ ] Verify no tests rely on has_alias returning False for bugs\n- [ ] Tests pass","status":"closed","priority":2,"issue_type":"bug","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:24:46.807078+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:44:38.594299+01:00","closed_at":"2026-01-23T19:44:38.594299+01:00","close_reason":"has_alias now only catches KeyError and ValueError. All tests pass."}
{"id":"llmring-5im","title":"Fix package discovery to not import packages","description":"## Problem\n\n`discover_package_lockfile()` in `src/llmring/lockfile_core.py` uses `importlib.resources.files(package_name)` which internally calls `importlib.import_module()`, executing the package's `__init__.py`.\n\nWe don't need to import the package - we just need to locate its files on disk.\n\n## Current code (lines 51-67)\n```python\nfrom importlib.resources import files, as_file\n\ndef discover_package_lockfile(package_name: str) -\u003e Optional[Path]:\n    ...\n    package_files = files(package_name)  # IMPORTS THE PACKAGE\n    lockfile_traversable = package_files / LOCKFILE_NAME\n    with as_file(lockfile_traversable) as lockfile_path:\n        if lockfile_path.exists():\n            return Path(lockfile_path)\n```\n\n## Fix\n\nUse `importlib.util.find_spec()` which locates a module WITHOUT importing it:\n\n```python\nimport importlib.util\n\ndef discover_package_lockfile(package_name: str) -\u003e Optional[Path]:\n    if not package_name or not package_name.strip():\n        return None\n    try:\n        spec = importlib.util.find_spec(package_name)\n        if spec is None:\n            return None\n        \n        # Get package directory from spec\n        if spec.submodule_search_locations:\n            # It's a package - use its location\n            package_dir = Path(spec.submodule_search_locations[0])\n        else:\n            # It's a single-file module - use parent dir\n            if spec.origin is None:\n                return None\n            package_dir = Path(spec.origin).parent\n        \n        lockfile_path = package_dir / LOCKFILE_NAME\n        if lockfile_path.exists():\n            return lockfile_path\n        return None\n    except (ModuleNotFoundError, ValueError, TypeError):\n        return None\n```\n\n## Benefits\n- No code execution from the package\n- Works with regular packages, namespace packages, and editable installs\n- `find_spec()` is the standard way to locate modules without importing\n\n## Acceptance criteria\n- [ ] `discover_package_lockfile()` uses `find_spec()` instead of `files()`\n- [ ] All existing tests still pass\n- [ ] Works with llmring's own lockfile (self-test)\n- [ ] Works with editable installs","status":"closed","priority":1,"issue_type":"bug","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:23:35.411677+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:36:18.713404+01:00","closed_at":"2026-01-23T19:36:18.713404+01:00","close_reason":"Used importlib.util.find_spec() instead of importlib.resources.files() to locate packages without importing them. All tests pass."}
{"id":"llmring-5sw","title":"Fix ruff E402/import-order failures (duplicate module docstrings)","description":"Ruff currently fails with hundreds of E402 errors because many modules have a second top-level string literal (duplicate module docstring) before imports (e.g. src/llmring/service.py, src/llmring/services/alias_resolver.py, src/llmring/providers/openai_api.py). Remove redundant literals so imports are immediately after the single module docstring, then re-run ruff check/format.","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-02T18:24:39.757829Z","created_by":"juanre","updated_at":"2026-01-02T19:18:15.903453Z","closed_at":"2026-01-02T19:18:15.903453Z","close_reason":"Ruff check/format clean; unit tests pass"}
{"id":"llmring-86p","title":"Fix bdh auto-reserve failing with \u003e50 paths","description":"bdh auto-reserve frequently fails with HTTP 422 because it tries to reserve more than 50 paths (server-side limit). This prevents proper file reservation/coordination. Fix by batching reservations (\u003c=50) or narrowing tracked paths for large changes.","status":"open","priority":2,"issue_type":"chore","created_at":"2026-01-02T20:53:18.361373Z","created_by":"juanre","updated_at":"2026-01-02T20:53:27.777099Z","dependencies":[{"issue_id":"llmring-86p","depends_on_id":"llmring-yww","type":"discovered-from","created_at":"2026-01-02T20:53:18.36271Z","created_by":"juanre"}]}
{"id":"llmring-935","title":"Extract shared _is_model_reference utility","description":"## Problem\n\nLogic to distinguish model references (openai:gpt-4) from namespaced aliases (libA:summarizer) is duplicated:\n\n**In alias_resolver.py:71:**\n```python\nif prefix.lower() in KNOWN_PROVIDERS:\n    return None  # Not a namespaced alias\n```\n\n**In lockfile_core.py:531-537:**\n```python\ndef _is_model_reference(self, alias_or_model: str) -\u003e bool:\n    if \":\" not in alias_or_model:\n        return False\n    prefix = alias_or_model.split(\":\", 1)[0]\n    return prefix in {\"openai\", \"anthropic\", \"google\", \"ollama\"}\n```\n\n## Fix\n\nExtract to shared utility in `src/llmring/utils.py`:\n\n```python\ndef is_model_reference(model_string: str) -\u003e bool:\n    \"\"\"Check if string is a provider:model reference vs namespace:alias.\n    \n    Returns True for \"openai:gpt-4\", False for \"libA:summarizer\".\n    \"\"\"\n    if \":\" not in model_string:\n        return False\n    prefix = model_string.split(\":\", 1)[0]\n    return prefix.lower() in KNOWN_PROVIDERS\n```\n\nThen use in both alias_resolver.py and lockfile_core.py.\n\n## Acceptance criteria\n- [ ] Add is_model_reference() to utils.py\n- [ ] Import and use in alias_resolver.py\n- [ ] Import and use in lockfile_core.py (replace _is_model_reference)\n- [ ] Tests pass","status":"open","priority":3,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:25:05.239829+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:25:05.239829+01:00"}
{"id":"llmring-cle","title":"Improve error messages with full TOML examples","description":"## Problem\n\nError messages in lockfile_core.py tell users to add packages to extends, but don't show the full TOML structure:\n\n```python\n# Current (line 563-564)\nreturn (\n    f\"  - {alias}: package '{namespace}' is not listed in [extends].packages. \"\n    f\"Add to lockfile: [extends] packages = [\\\"{namespace}\\\"]\"\n)\n```\n\nUsers unfamiliar with TOML might not know WHERE to add this.\n\n## Fix\n\nInclude a more complete example:\n\n```python\nreturn (\n    f\"  - {alias}: package '{namespace}' is not listed in [extends].packages.\\n\"\n    f\"    Add to your llmring.lock:\\n\"\n    f\"    [extends]\\n\"\n    f\"    packages = [\\\"{namespace}\\\"]\"\n)\n```\n\n## Acceptance criteria\n- [ ] Error messages include multi-line TOML example\n- [ ] Shows exact location in lockfile structure\n- [ ] Tests updated to match new error format","status":"open","priority":4,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:25:33.534715+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:25:33.534715+01:00"}
{"id":"llmring-cub","title":"Remove mocks/TODOs from tests to match project policy","description":"Project policy says never mock in tests + do not leave TODO tracking in code, but many tests import unittest.mock/AsyncMock and there are TODO comments (e.g. tests/test_usage_logging.py, tests/test_logging_decorators.py, tests/unit/test_alias_resolver.py, tests/mcp/server/test_stdio_transport.py). Replace with real integration-style tests and move TODOs into BeadHub issues.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T18:25:05.331608Z","created_by":"juanre","updated_at":"2026-01-02T18:26:35.060309Z"}
{"id":"llmring-kci","title":"Fix registry URL validation: localhost HTTP allowed vs blocked","description":"InputValidator.validate_registry_url says HTTP is allowed for localhost/test domains, but later blocks localhost/127.0.0.1 as dangerous hostnames; this prevents local registry development unless using file://. Decide desired security policy and make logic consistent.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-02T18:25:09.465822Z","created_by":"juanre","updated_at":"2026-01-02T21:30:35.546366Z","closed_at":"2026-01-02T21:30:35.546366Z","close_reason":"Made validate_registry_url consistent: allow http for localhost/loopback and test domains; reject unspecified IPs; warn (not block) private/link-local; added unit tests."}
{"id":"llmring-ku5","title":"Add circular dependency detection for extends","description":"## Problem\n\nIf Package A's lockfile extends Package B, and Package B's lockfile extends Package A, the current implementation would attempt to load both lockfiles without detecting the cycle.\n\nWhile unlikely in practice (packages define their OWN lockfile, they don't typically extend each other circularly), it's a potential edge case.\n\n## Current behavior\n\nThe `_resolve_namespaced_alias` method in alias_resolver.py loads package lockfiles but doesn't track the resolution chain. If libA:alias resolved by looking up alias in libA's lockfile, and libA's lockfile tried to resolve libB:something, we'd have no cycle detection.\n\nActually, looking at the code more carefully - the current implementation only resolves ONE level. When you request `libA:summarizer`:\n1. Load libA's lockfile\n2. Look up `summarizer` in libA's lockfile\n3. Return the model reference\n\nIt does NOT follow any `[extends]` in libA's lockfile. So circular extends isn't actually a problem with the CURRENT design.\n\n## Decision needed\n\nShould we:\n1. Document that extends are NOT recursive (current behavior)\n2. Add recursive resolution with cycle detection\n3. Add validation that warns if a package's lockfile has its own [extends]\n\n## Acceptance criteria\n- [ ] Decide on approach\n- [ ] Document the chosen behavior in SKILL.md\n- [ ] Add test verifying the behavior","status":"open","priority":3,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:25:51.373518+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:25:51.373518+01:00"}
{"id":"llmring-n9k","title":"Add edge case tests for lockfile composability","description":"## Problem\n\nThe code review identified missing test coverage for:\n\n1. **Concurrent access** to `_extended_lockfiles` cache\n2. **Package lockfile parse error** - what happens if package has lockfile but it's malformed?\n3. **Empty bindings** - package lockfile exists but has no aliases\n4. **Profile-specific namespaced alias** - `libA:summarizer` with profile=\"dev\"\n\n## Tests to add\n\n```python\nclass TestNamespacedAliasEdgeCases:\n    def test_package_lockfile_parse_error(self, tmp_path):\n        \"\"\"Should handle malformed package lockfile gracefully.\"\"\"\n        # Create package with invalid lockfile content\n        \n    def test_package_lockfile_empty_bindings(self, tmp_path):\n        \"\"\"Should return clear error when package has no aliases.\"\"\"\n        \n    def test_namespaced_alias_with_profile(self):\n        \"\"\"Should resolve libA:summarizer with specific profile.\"\"\"\n        \n    def test_concurrent_cache_access(self):\n        \"\"\"Should handle concurrent access to _extended_lockfiles.\"\"\"\n        # Use threading or asyncio to test concurrent access\n```\n\n## Acceptance criteria\n- [ ] Add test for malformed package lockfile\n- [ ] Add test for empty bindings in package lockfile\n- [ ] Add test for profile-specific namespaced resolution\n- [ ] Add test for concurrent cache access\n- [ ] All tests pass","status":"closed","priority":2,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:25:15.13972+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:45:59.001138+01:00","closed_at":"2026-01-23T19:45:59.001138+01:00","close_reason":"Added 3 edge case tests: concurrent cache access, profile-specific namespaced alias, and package lockfile with no matching alias. All tests pass."}
{"id":"llmring-ph3","title":"Fix registry datetime parsing for ISO strings with Z suffix","description":"datetime.fromisoformat() in src/llmring/registry.py:290 doesn't handle '2025-09-01T00:00:00Z' - the trailing Z suffix. Test test_fetch_version_from_file_scheme fails. Need to strip Z or use dateutil.parser.","status":"in_progress","priority":1,"issue_type":"bug","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:47:12.08454+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T20:40:25.954376+01:00"}
{"id":"llmring-qls","title":"Cache lockfiles in require_aliases to avoid redundant loading","description":"## Problem\n\nIn `Lockfile.require_aliases()` at `src/llmring/lockfile_core.py`, each namespaced alias loads its package lockfile independently via `_check_namespaced_alias()`.\n\nIf you require 5 aliases from the same package:\n```python\nlockfile.require_aliases([\"libA:summarizer\", \"libA:analyzer\", \"libA:embedder\", \"libA:chat\", \"libA:translate\"])\n```\n\nThe lockfile for `libA` is loaded 5 times.\n\n## Current flow\n```\nrequire_aliases() \n  → _check_namespaced_alias(\"libA:summarizer\") → discover + load libA lockfile\n  → _check_namespaced_alias(\"libA:analyzer\")   → discover + load libA lockfile AGAIN\n  → _check_namespaced_alias(\"libA:embedder\")   → discover + load libA lockfile AGAIN\n  ...\n```\n\n## Fix\n\nCache loaded lockfiles within the scope of `require_aliases`:\n\n```python\ndef require_aliases(self, required: List[str], ...):\n    # Cache for this validation run\n    _package_lockfiles: Dict[str, Optional[Lockfile]] = {}\n    \n    def get_package_lockfile(namespace: str) -\u003e Optional[Lockfile]:\n        if namespace not in _package_lockfiles:\n            path = discover_package_lockfile(namespace)\n            _package_lockfiles[namespace] = Lockfile.load(path) if path else None\n        return _package_lockfiles[namespace]\n    \n    # Use get_package_lockfile in _check_namespaced_alias\n```\n\n## Acceptance criteria\n- [ ] Add local cache dict in require_aliases\n- [ ] Pass cache to _check_namespaced_alias or refactor to use it\n- [ ] Same package lockfile loaded at most once per require_aliases call\n- [ ] All tests pass","status":"open","priority":3,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:24:25.49328+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:24:25.49328+01:00"}
{"id":"llmring-vme","title":"Add thread-safety to _extended_lockfiles cache","description":"## Problem\n\n`AliasResolver._extended_lockfiles` cache in `src/llmring/services/alias_resolver.py:49` is a plain dict accessed without synchronization.\n\nIn concurrent environments (e.g., async with multiple coroutines, or threaded servers), multiple threads could:\n1. Both check cache and miss\n2. Both load the same lockfile  \n3. Both write to cache, causing race conditions\n\n## Current code\n```python\nclass AliasResolver:\n    def __init__(self, ...):\n        self._extended_lockfiles: Dict[str, Optional[Lockfile]] = {}  # Not thread-safe\n\n    def _load_extended_lockfile(self, package_name: str) -\u003e Optional[Lockfile]:\n        if package_name in self._extended_lockfiles:  # Race condition\n            return self._extended_lockfiles[package_name]\n        \n        lockfile_path = discover_package_lockfile(package_name)\n        # ... load lockfile ...\n        self._extended_lockfiles[package_name] = lockfile  # Race condition\n```\n\n## Fix\n\nUse `threading.Lock` to synchronize cache access:\n\n```python\nimport threading\n\nclass AliasResolver:\n    def __init__(self, ...):\n        self._extended_lockfiles: Dict[str, Optional[Lockfile]] = {}\n        self._extended_lockfiles_lock = threading.Lock()\n\n    def _load_extended_lockfile(self, package_name: str) -\u003e Optional[Lockfile]:\n        with self._extended_lockfiles_lock:\n            if package_name in self._extended_lockfiles:\n                return self._extended_lockfiles[package_name]\n        \n        # Load outside lock to avoid blocking other threads\n        lockfile = self._load_lockfile_from_disk(package_name)\n        \n        with self._extended_lockfiles_lock:\n            # Double-check in case another thread loaded it\n            if package_name not in self._extended_lockfiles:\n                self._extended_lockfiles[package_name] = lockfile\n            return self._extended_lockfiles[package_name]\n```\n\n## Acceptance criteria\n- [ ] Add threading.Lock to AliasResolver\n- [ ] Wrap cache reads and writes in lock\n- [ ] Use double-checked locking pattern for performance\n- [ ] All existing tests pass","status":"closed","priority":2,"issue_type":"bug","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:23:56.261141+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:41:43.321125+01:00","closed_at":"2026-01-23T19:41:43.321125+01:00","close_reason":"Added threading.Lock with double-checked locking pattern. All tests pass."}
{"id":"llmring-wf9","title":"Investigate OpenAI PDF ingestion failing integration test","description":"Integration suite currently fails tests/integration/test_file_processing.py::TestFileProcessing::test_pdf_processing_openai: model responds it cannot read PDFs, suggesting the PDF payload is not being delivered or the wrong API path is used. Confirm analyze_file output format + OpenAI provider PDF handling (Assistants/Responses) and make test deterministic.","status":"open","priority":2,"issue_type":"bug","created_at":"2026-01-02T18:26:45.186821Z","created_by":"juanre","updated_at":"2026-01-02T18:26:45.186821Z"}
{"id":"llmring-wh4","title":"Enhance cmd_lock_check to show actual aliases from packages","description":"## Problem\n\n`llmring lock check` verifies that extended packages have lockfiles, but the output shows \"Aliases: summarizer, analyzer\" - meaning it DOES list aliases. However, based on code review, the implementation should be verified to ensure it actually loads and lists aliases correctly.\n\nLooking at `cmd_lock_check` in cli.py, it does call `pkg_lockfile.list_aliases()`, but the code reviewer flagged this as potentially not working.\n\n## Verify and fix\n\n1. Verify `llmring lock check` actually shows aliases from extended packages\n2. Ensure the output matches the documented format in SKILL.md:\n   ```\n   [extends]\n     ✓ libA: found llmring.lock\n       Aliases: summarizer, analyzer, embedder\n   ```\n\n## Acceptance criteria\n- [ ] Run `llmring lock check` against a real lockfile with extends\n- [ ] Verify aliases are listed correctly\n- [ ] Fix if not working\n- [ ] Add test to verify alias listing","status":"open","priority":3,"issue_type":"task","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:25:25.098983+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:25:25.098983+01:00"}
{"id":"llmring-y94","title":"Add validation in _check_namespaced_alias before split","description":"## Problem\n\nIn `Lockfile._check_namespaced_alias()` at `src/llmring/lockfile_core.py:549`:\n\n```python\ndef _check_namespaced_alias(self, alias: str, profile: Optional[str]) -\u003e Optional[str]:\n    namespace, alias_name = alias.split(\":\", 1)  # Assumes colon exists\n```\n\nThe caller at line 506 checks `if \":\" in alias`, but this method doesn't validate. Defensive programming would add the check here too.\n\n## Fix\n\nAdd validation at the start of the method:\n\n```python\ndef _check_namespaced_alias(self, alias: str, profile: Optional[str]) -\u003e Optional[str]:\n    \"\"\"Check if a namespaced alias (package:alias) exists.\n    \n    Args:\n        alias: Must contain \":\" (e.g., \"libA:summarizer\")\n        ...\n    \"\"\"\n    if \":\" not in alias:\n        raise ValueError(f\"_check_namespaced_alias called with non-namespaced alias: {alias!r}\")\n    \n    namespace, alias_name = alias.split(\":\", 1)\n```\n\nOr document the precondition clearly in the docstring.\n\n## Acceptance criteria\n- [ ] Add validation or clear docstring about precondition\n- [ ] Raise informative error if precondition violated\n- [ ] Tests pass","status":"open","priority":3,"issue_type":"bug","owner":"juan@juanreyero.com","created_at":"2026-01-23T19:24:56.015409+01:00","created_by":"Juan Reyero","updated_at":"2026-01-23T19:24:56.015409+01:00"}
{"id":"llmring-yww","title":"Fix pyright typecheck failures (CI gate)","description":"CI runs `uv run pyright src/llmring/` and it currently reports hundreds of errors (timeout sentinel typing, BaseLLMProvider missing methods used by service, dict-vs-str assumptions in CLI/server commands, Optional handling). Fix core typings so pyright passes.","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-02T18:32:40.572329Z","created_by":"juanre","updated_at":"2026-01-02T20:52:43.447493Z","closed_at":"2026-01-02T20:52:43.447493Z","close_reason":"Pyright passes (0 errors), ruff clean, unit tests passing"}
